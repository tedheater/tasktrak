<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Tasks</title>
<link href="https://fonts.googleapis.com/css2?family=SF+Pro+Display:wght@200;300;400&display=swap" rel="stylesheet">
<link href="https://fonts.googleapis.com/css2?family=Outfit:wght@200;300;400&display=swap" rel="stylesheet">
<style>
  *, *::before, *::after { margin: 0; padding: 0; box-sizing: border-box; }

  body {
    background: #000;
    color: #f5f5f7;
    font-family: 'Outfit', -apple-system, 'SF Pro Display', 'Helvetica Neue', sans-serif;
    font-weight: 200;
    min-height: 100vh;
    display: flex;
    justify-content: center;
    padding: 32px 40px;
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale;
  }

  .container {
    width: 100%;
    max-width: 960px;
  }

  h1 {
    font-size: 14px;
    font-weight: 300;
    letter-spacing: 0.2em;
    text-transform: uppercase;
    color: #555;
    margin-bottom: 48px;
  }

  .header-row {
    display: grid;
    grid-template-columns: 12px 1fr 140px 200px 40px;
    gap: 0;
    padding: 0 0 16px 0;
    border-bottom: 1px solid #1a1a1a;
    margin-bottom: 8px;
  }

  .header-row span {
    font-size: 11px;
    font-weight: 300;
    letter-spacing: 0.15em;
    text-transform: uppercase;
    color: #444;
    cursor: pointer;
    user-select: none;
    display: flex;
    align-items: center;
    gap: 4px;
    transition: color 0.2s ease;
  }

  .header-row span:hover {
    color: #777;
  }

  .header-row span:first-child {
    cursor: default;
  }

  .header-row span:first-child:hover {
    color: #444;
  }

  .sort-glyph {
    font-size: 8px;
    opacity: 0;
    transition: opacity 0.2s ease, transform 0.2s ease;
  }

  .header-row span:hover .sort-glyph,
  .sort-glyph.active {
    opacity: 1;
  }

  .sort-glyph.desc {
    transform: rotate(180deg);
  }

  /* --- Section Headers --- */
  .section-row {
    padding: 32px 0 12px 0;
    border-bottom: 1px solid #1a1a1a;
    animation: fadeIn 0.4s ease forwards;
    opacity: 0;
    display: flex;
    align-items: center;
    gap: 8px;
  }

  .section-label {
    background: none;
    border: none;
    outline: none;
    color: #555;
    font-family: 'Outfit', -apple-system, 'SF Pro Display', sans-serif;
    font-weight: 300;
    font-size: 12px;
    letter-spacing: 0.15em;
    text-transform: uppercase;
    width: 100%;
  }

  .section-label::placeholder {
    color: #2a2a2a;
  }

  .section-delete-btn {
    background: none;
    border: none;
    color: #1a1a1a;
    font-size: 14px;
    cursor: pointer;
    transition: color 0.3s ease;
    flex-shrink: 0;
  }

  .section-row:hover .section-delete-btn {
    color: #444;
  }

  .section-delete-btn:hover {
    color: #ff453a !important;
  }

  /* --- Task Rows --- */
  .task-row {
    display: grid;
    grid-template-columns: 12px 1fr 140px 200px 40px;
    gap: 0;
    align-items: center;
    padding: 18px 0;
    border-bottom: 1px solid #0d0d0d;
    transition: border-color 0.3s ease, opacity 0.4s ease;
    animation: fadeIn 0.4s ease forwards;
    opacity: 0;
    cursor: grab;
  }

  .task-row:hover {
    border-bottom-color: #1a1a1a;
  }

  .task-row.dragging {
    opacity: 0.3;
    cursor: grabbing;
  }

  .drag-over-top {
    border-top: 2px solid #333 !important;
  }

  .drag-over-bottom {
    border-bottom: 2px solid #333 !important;
  }

  .task-row.completed .task-title-input {
    text-decoration: line-through;
    color: #333;
  }

  .task-row.completed .task-date-input {
    color: #2a2a2a;
  }

  .task-row.completed {
    opacity: 0.4;
  }

  @keyframes fadeIn {
    to { opacity: 1; }
  }

  /* --- Priority Dot --- */
  .priority-dot {
    width: 6px;
    height: 6px;
    border-radius: 50%;
    cursor: pointer;
    transition: background 0.2s ease, box-shadow 0.2s ease, transform 0.15s ease;
    flex-shrink: 0;
    justify-self: center;
    background: transparent;
    /* invisible idle state, but show ring on row hover */
  }

  .task-row:hover .priority-dot:not(.orange):not(.red) {
    box-shadow: 0 0 0 1.5px #333;
  }

  .priority-dot:hover {
    transform: scale(1.6);
    box-shadow: 0 0 0 1.5px #555 !important;
  }

  .priority-dot.orange {
    background: #ff9f0a;
  }

  .priority-dot.red {
    background: #ff453a;
  }

  .task-title-cell {
    display: flex;
    align-items: center;
    gap: 12px;
    min-width: 0;
  }

  .task-complete-btn {
    width: 18px;
    height: 18px;
    border-radius: 50%;
    border: 1px solid #2c2c2e;
    background: transparent;
    color: transparent;
    font-size: 11px;
    line-height: 1;
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    flex-shrink: 0;
    opacity: 0.55;
    transition: border-color 0.2s ease, background 0.2s ease, color 0.2s ease, opacity 0.2s ease, transform 0.15s ease;
  }

  .task-row:hover .task-complete-btn {
    border-color: #4a4a4a;
    opacity: 0.95;
  }

  .task-complete-btn:hover {
    border-color: #30d158;
    color: #30d158;
    transform: scale(1.06);
  }

  .task-complete-btn:focus-visible {
    outline: 1px solid #4a4a4a;
    outline-offset: 2px;
    opacity: 1;
  }

  .task-row.completed .task-complete-btn {
    background: rgba(48, 209, 88, 0.15);
    border-color: #30d158;
    color: #30d158;
    opacity: 1;
  }

  /* --- Inputs --- */
  .task-title-input,
  .task-date-input {
    background: none;
    border: none;
    outline: none;
    color: #f5f5f7;
    font-family: 'Outfit', -apple-system, 'SF Pro Display', sans-serif;
    font-weight: 200;
    font-size: 28px;
    width: 100%;
    transition: color 0.3s ease;
  }

  .task-title-input {
    cursor: text;
  }

  .task-title-input::placeholder,
  .task-date-input::placeholder {
    color: #222;
    transition: color 0.3s ease;
  }

  .task-title-input:focus::placeholder,
  .task-date-input:focus::placeholder {
    color: #333;
  }

  .task-date-input {
    font-size: 22px;
    color: #666;
    text-align: right;
    padding-right: 16px;
  }

  /* --- Overdue Date --- */
  .task-date-input.overdue {
    color: #c45a3a;
  }

  .task-row.completed .task-date-input.overdue {
    color: #2a2a2a;
  }

  /* --- Status Input --- */
  .task-status-input {
    background: none;
    border: none;
    outline: none;
    color: #555;
    font-family: 'Outfit', -apple-system, 'SF Pro Display', sans-serif;
    font-weight: 300;
    font-size: 14px;
    letter-spacing: 0.05em;
    width: 100%;
    text-align: center;
    transition: color 0.3s ease;
  }

  .task-status-input::placeholder {
    color: #222;
    transition: color 0.3s ease;
  }

  .task-status-input:focus::placeholder {
    color: #333;
  }

  .task-row.completed .task-status-input {
    color: #2a2a2a !important;
  }

  /* Status colors */
  .task-status-input.status-pending  { color: #ff9f0a; }
  .task-status-input.status-waiting  { color: #bf5af2; }
  .task-status-input.status-due      { color: #ff453a; }
  .task-status-input.status-done     { color: #30d158; }
  .task-status-input.status-blocked  { color: #ff6961; }
  .task-status-input.status-custom   { color: #64d2ff; }

  /* --- Status Autocomplete --- */
  .status-wrapper {
    position: relative;
  }

  .status-dropdown {
    position: absolute;
    top: 100%;
    left: 0;
    right: 0;
    background: #111;
    border: 1px solid #222;
    border-radius: 6px;
    margin-top: 4px;
    padding: 4px 0;
    z-index: 100;
    display: none;
    max-height: 160px;
    overflow-y: auto;
  }

  .status-dropdown.visible {
    display: block;
  }

  .status-option {
    padding: 6px 12px;
    font-family: 'Outfit', -apple-system, 'SF Pro Display', sans-serif;
    font-weight: 300;
    font-size: 13px;
    color: #888;
    cursor: pointer;
    transition: background 0.15s ease, color 0.15s ease;
  }

  .status-option:hover,
  .status-option.active {
    background: #1a1a1a;
    color: #ccc;
  }

  /* --- Inline Notes --- */
  .note-field {
    grid-column: 2 / 5;
    background: none;
    border: none;
    outline: none;
    color: #444;
    font-family: 'Outfit', -apple-system, 'SF Pro Display', sans-serif;
    font-weight: 200;
    font-size: 16px;
    width: 100%;
    padding: 8px 0 0 24px;
    resize: none;
    overflow: hidden;
    line-height: 1.5;
    min-height: 28px;
  }

  .note-field::placeholder {
    color: #222;
  }

  .task-row.has-note {
    grid-template-rows: auto auto;
  }

  /* --- Delete Button --- */
  .delete-btn {
    background: none;
    border: none;
    color: #1a1a1a;
    font-size: 18px;
    cursor: pointer;
    transition: color 0.3s ease;
    display: flex;
    align-items: center;
    justify-content: center;
    width: 32px;
    height: 32px;
    border-radius: 50%;
  }

  .task-row:hover .delete-btn {
    color: #444;
  }

  .delete-btn:hover {
    color: #ff453a !important;
  }

  /* --- Add Row --- */
  .add-row {
    display: grid;
    grid-template-columns: 12px 1fr 140px 200px 40px;
    gap: 0;
    align-items: center;
    padding: 18px 0;
    cursor: text;
    opacity: 0.4;
    transition: opacity 0.3s ease;
  }

  .add-row:hover {
    opacity: 0.7;
  }

  .add-label {
    font-size: 28px;
    font-weight: 200;
    color: #333;
    user-select: none;
    grid-column: 2;
  }

  /* --- Add Section Button --- */
  .add-section-row {
    padding: 12px 0;
    cursor: pointer;
    opacity: 0;
    transition: opacity 0.3s ease;
    user-select: none;
  }

  .container:hover .add-section-row {
    opacity: 0.3;
  }

  .add-section-row:hover {
    opacity: 0.6 !important;
  }

  .add-section-label {
    font-size: 12px;
    font-weight: 300;
    letter-spacing: 0.15em;
    text-transform: uppercase;
    color: #444;
  }

  /* --- Keyboard Hint --- */
  .kbd-hint {
    position: fixed;
    bottom: 32px;
    left: 50%;
    transform: translateX(-50%);
    font-size: 11px;
    font-weight: 300;
    letter-spacing: 0.1em;
    color: #2a2a2a;
  }

  .kbd-hint kbd {
    display: inline-block;
    padding: 2px 6px;
    border: 1px solid #222;
    border-radius: 4px;
    font-family: inherit;
    font-size: 10px;
    margin: 0 2px;
  }

  /* --- Status Manager --- */
  .status-manager-btn {
    font-size: 11px;
    font-weight: 300;
    letter-spacing: 0.15em;
    text-transform: uppercase;
    color: #333;
    background: none;
    border: none;
    cursor: pointer;
    padding: 8px 0;
    transition: color 0.2s ease;
    font-family: 'Outfit', -apple-system, 'SF Pro Display', sans-serif;
  }

  .status-manager-btn:hover {
    color: #666;
  }

  .data-actions {
    display: flex;
    gap: 10px;
    align-items: center;
    flex-wrap: wrap;
  }

  .status-manager-overlay {
    position: fixed;
    inset: 0;
    background: rgba(0,0,0,0.6);
    z-index: 500;
    display: none;
    align-items: center;
    justify-content: center;
  }

  .status-manager-overlay.visible {
    display: flex;
  }

  .status-manager-panel {
    background: #111;
    border: 1px solid #222;
    border-radius: 10px;
    padding: 24px;
    width: 320px;
    max-height: 420px;
    overflow-y: auto;
  }

  .status-manager-panel h2 {
    font-size: 13px;
    font-weight: 300;
    letter-spacing: 0.15em;
    text-transform: uppercase;
    color: #666;
    margin-bottom: 16px;
  }

  .status-manager-item {
    display: flex;
    align-items: center;
    gap: 8px;
    padding: 6px 0;
    border-bottom: 1px solid #1a1a1a;
  }

  .status-manager-item .color-dot {
    width: 8px;
    height: 8px;
    border-radius: 50%;
    flex-shrink: 0;
  }

  .status-manager-item input {
    flex: 1;
    background: none;
    border: none;
    outline: none;
    color: #ccc;
    font-family: 'Outfit', -apple-system, 'SF Pro Display', sans-serif;
    font-weight: 300;
    font-size: 14px;
  }

  .status-manager-item input::placeholder {
    color: #333;
  }

  .status-manager-item .status-del-btn {
    background: none;
    border: none;
    color: #333;
    font-size: 14px;
    cursor: pointer;
    transition: color 0.2s ease;
    padding: 0 4px;
  }

  .status-manager-item .status-del-btn:hover {
    color: #ff453a;
  }

  .status-manager-add {
    margin-top: 12px;
    display: flex;
    gap: 8px;
  }

  .status-manager-add input {
    flex: 1;
    background: none;
    border: 1px solid #222;
    border-radius: 6px;
    outline: none;
    color: #ccc;
    font-family: 'Outfit', -apple-system, 'SF Pro Display', sans-serif;
    font-weight: 300;
    font-size: 13px;
    padding: 6px 10px;
  }

  .status-manager-add input::placeholder {
    color: #333;
  }

  .status-manager-add input:focus {
    border-color: #333;
  }

  .status-manager-add button {
    background: none;
    border: 1px solid #222;
    border-radius: 6px;
    color: #555;
    font-family: 'Outfit', -apple-system, 'SF Pro Display', sans-serif;
    font-weight: 300;
    font-size: 13px;
    padding: 6px 12px;
    cursor: pointer;
    transition: color 0.2s ease, border-color 0.2s ease;
  }

  .status-manager-add button:hover {
    color: #aaa;
    border-color: #444;
  }

  .status-manager-close {
    margin-top: 16px;
    width: 100%;
    background: none;
    border: 1px solid #1a1a1a;
    border-radius: 6px;
    color: #555;
    font-family: 'Outfit', -apple-system, 'SF Pro Display', sans-serif;
    font-weight: 300;
    font-size: 12px;
    letter-spacing: 0.1em;
    text-transform: uppercase;
    padding: 8px;
    cursor: pointer;
    transition: color 0.2s ease, border-color 0.2s ease;
  }

  .status-manager-close:hover {
    color: #aaa;
    border-color: #333;
  }

  /* --- Date Group Dividers --- */
  .date-divider {
    padding: 24px 0 8px 0;
    font-size: 11px;
    font-weight: 300;
    letter-spacing: 0.12em;
    text-transform: uppercase;
    color: #333;
    border-bottom: 1px solid #141414;
    animation: fadeIn 0.4s ease forwards;
    opacity: 0;
  }

  @media (max-width: 820px) {
    body {
      padding: 20px 16px 88px;
    }

    .container {
      max-width: 100%;
    }

    h1 {
      margin-bottom: 28px;
    }

    .header-row {
      grid-template-columns: minmax(0, 1fr) 90px 72px;
      gap: 8px;
      padding: 0 0 12px 30px;
    }

    .header-row span:first-child,
    .header-row span:last-child {
      display: none;
    }

    .header-row span[data-sort="date"] {
      padding-right: 0 !important;
    }

    .task-row,
    .add-row {
      grid-template-columns: 12px minmax(0, 1fr) auto;
      row-gap: 8px;
      align-items: start;
      padding: 14px 0;
    }

    .task-row {
      cursor: default;
    }

    .priority-dot {
      margin-top: 8px;
    }

    .task-title-cell {
      grid-column: 2;
      grid-row: 1;
      gap: 10px;
    }

    .status-wrapper {
      grid-column: 2;
      grid-row: 2;
      min-width: 0;
    }

    .task-date-input {
      grid-column: 3;
      grid-row: 2;
      width: auto;
      min-width: 72px;
      padding-right: 0;
      text-align: right;
      align-self: center;
      font-size: 16px;
    }

    .delete-btn {
      grid-column: 3;
      grid-row: 1;
      color: #555;
    }

    .task-title-input {
      font-size: 20px;
    }

    .task-status-input {
      text-align: left;
      font-size: 16px;
    }

    .add-label {
      font-size: 20px;
    }

    .section-label,
    .note-field,
    #status-manager-new,
    .status-manager-item input {
      font-size: 16px;
    }

    .note-field {
      grid-column: 2 / 4;
      padding: 4px 0 0 0;
      font-size: 15px;
    }

    .task-complete-btn {
      width: 20px;
      height: 20px;
      opacity: 0.95;
      border-color: #4a4a4a;
    }

    .container:hover .add-section-row,
    .add-section-row {
      opacity: 0.55;
    }

    .status-manager-panel {
      width: min(92vw, 340px);
      max-height: 75vh;
      padding: 18px;
    }

    .kbd-hint {
      display: none;
    }
  }

  @media (hover: none), (pointer: coarse) {
    .delete-btn,
    .section-delete-btn {
      color: #555;
    }

    .task-complete-btn {
      border-color: #4a4a4a;
      opacity: 0.95;
    }

    .container:hover .add-section-row,
    .add-section-row {
      opacity: 0.55;
    }
  }
</style>
</head>
<body>

<div class="container">
  <h1>Tasks</h1>
  <div class="header-row">
    <span></span>
    <span data-sort="title">Task <span class="sort-glyph">&#9650;</span></span>
    <span data-sort="status">Status <span class="sort-glyph">&#9650;</span></span>
    <span data-sort="date" style="justify-content:flex-end;padding-right:16px">Date <span class="sort-glyph">&#9650;</span></span>
    <span></span>
  </div>
  <div id="task-list"></div>
  <div class="add-row" id="add-row">
    <span></span>
    <span class="add-label">+ New task</span>
  </div>
  <div style="display:flex;gap:16px;align-items:center;justify-content:space-between;flex-wrap:wrap;">
    <div class="add-section-row" id="add-section">
      <span class="add-section-label">+ Section</span>
    </div>
    <div class="data-actions">
      <button class="status-manager-btn" id="manage-statuses-btn" type="button">Manage Statuses</button>
      <button class="status-manager-btn" id="export-data-btn" type="button">Export Data</button>
      <button class="status-manager-btn" id="import-data-btn" type="button">Import Data</button>
      <input type="file" id="import-file-input" accept=".json,application/json" style="display:none;">
    </div>
  </div>
</div>

<!-- Status Manager Overlay -->
<div class="status-manager-overlay" id="status-manager-overlay">
  <div class="status-manager-panel">
    <h2>Status Values</h2>
    <div id="status-manager-list"></div>
    <div class="status-manager-add">
      <input type="text" id="status-manager-new" placeholder="New status...">
      <button id="status-manager-add-btn">Add</button>
    </div>
    <button class="status-manager-close" id="status-manager-close">Done</button>
  </div>
</div>

<div class="kbd-hint">
  <kbd>Tab</kbd> to move between fields · <kbd>Enter</kbd> to advance · <kbd>Shift+Enter</kbd> note
</div>

<script>
const taskList = document.getElementById('task-list');
const addRow = document.getElementById('add-row');
const addSectionBtn = document.getElementById('add-section');
const exportDataBtn = document.getElementById('export-data-btn');
const importDataBtn = document.getElementById('import-data-btn');
const importFileInput = document.getElementById('import-file-input');
const disableDragReorder = window.matchMedia('(hover: none), (pointer: coarse)').matches;

// --- Status autocomplete ---
const DEFAULT_STATUSES = ['Pending', 'Waiting', 'Due'];
const statusSuggestions = new Set(DEFAULT_STATUSES);

const statusColorMap = {
  pending: 'status-pending',
  waiting: 'status-waiting',
  due: 'status-due',
  done: 'status-done',
  blocked: 'status-blocked',
};

function applyStatusColor(input) {
  // Remove all status color classes
  input.classList.remove('status-pending', 'status-waiting', 'status-due', 'status-done', 'status-blocked', 'status-custom');
  const val = input.value.trim().toLowerCase();
  if (!val) return;
  const cls = statusColorMap[val];
  if (cls) {
    input.classList.add(cls);
  } else {
    input.classList.add('status-custom');
  }
}

function collectStatuses() {
  taskList.querySelectorAll('.task-status-input').forEach(input => {
    const val = input.value.trim();
    if (val) statusSuggestions.add(val);
  });
}

function getFilteredSuggestions(query) {
  const q = query.toLowerCase();
  return Array.from(statusSuggestions).filter(s => s.toLowerCase().includes(q) && s.toLowerCase() !== q);
}

function createStatusField(row, statusValue = '') {
  const wrapper = document.createElement('div');
  wrapper.className = 'status-wrapper';

  const input = document.createElement('input');
  input.type = 'text';
  input.className = 'task-status-input';
  input.placeholder = 'Status';
  input.value = statusValue;
  applyStatusColor(input);

  const dropdown = document.createElement('div');
  dropdown.className = 'status-dropdown';

  let activeIndex = -1;

  function showDropdown(filter = '') {
    const suggestions = filter ? getFilteredSuggestions(filter) : Array.from(statusSuggestions);
    if (suggestions.length === 0) {
      dropdown.classList.remove('visible');
      return;
    }
    dropdown.innerHTML = '';
    activeIndex = -1;
    suggestions.forEach((s, i) => {
      const opt = document.createElement('div');
      opt.className = 'status-option';
      opt.textContent = s;
      opt.addEventListener('mousedown', (e) => {
        e.preventDefault();
        input.value = s;
        applyStatusColor(input);
        dropdown.classList.remove('visible');
        saveTasks();
      });
      dropdown.appendChild(opt);
    });
    dropdown.classList.add('visible');
  }

  function hideDropdown() {
    dropdown.classList.remove('visible');
    activeIndex = -1;
  }

  input.addEventListener('focus', () => {
    showDropdown(input.value.trim());
  });

  input.addEventListener('input', () => {
    applyStatusColor(input);
    showDropdown(input.value.trim());
    saveTasks();
  });

  input.addEventListener('blur', () => {
    hideDropdown();
    applyStatusColor(input);
    const val = input.value.trim();
    if (val) statusSuggestions.add(val);
    setTimeout(saveTasks, 50);
  });

  input.addEventListener('keydown', (e) => {
    const options = dropdown.querySelectorAll('.status-option');
    if (e.key === 'ArrowDown') {
      e.preventDefault();
      activeIndex = Math.min(activeIndex + 1, options.length - 1);
      options.forEach((o, i) => o.classList.toggle('active', i === activeIndex));
    } else if (e.key === 'ArrowUp') {
      e.preventDefault();
      activeIndex = Math.max(activeIndex - 1, 0);
      options.forEach((o, i) => o.classList.toggle('active', i === activeIndex));
    } else if (e.key === 'Enter') {
      e.preventDefault();
      if (activeIndex >= 0 && options[activeIndex]) {
        input.value = options[activeIndex].textContent;
        applyStatusColor(input);
        hideDropdown();
        saveTasks();
      } else {
        // Move to date field
        const dateInput = row.querySelector('.task-date-input');
        if (dateInput) dateInput.focus();
      }
    } else if (e.key === 'Tab') {
      hideDropdown();
      if (activeIndex >= 0 && options[activeIndex]) {
        input.value = options[activeIndex].textContent;
        applyStatusColor(input);
        saveTasks();
      }
    } else if (e.key === 'Escape') {
      hideDropdown();
    }
  });

  wrapper.appendChild(input);
  wrapper.appendChild(dropdown);
  return wrapper;
}

// --- Date parsing ---

function parseNaturalDate(input) {
  if (!input || !input.trim()) return '';
  const text = input.trim().toLowerCase().replace(/\s+/g, ' ');
  const now = new Date();
  const year = now.getFullYear();

  if (text === 'today') return formatDate(now);
  if (text === 'tomorrow' || text === 'tommorrow' || text === 'tmr' || text === 'tmrw') {
    const d = new Date(now); d.setDate(d.getDate() + 1); return formatDate(d);
  }
  if (text === 'yesterday') {
    const d = new Date(now); d.setDate(d.getDate() - 1); return formatDate(d);
  }
  if (text === 'next week' || text === 'next wk') {
    const d = new Date(now); d.setDate(d.getDate() + 7); return formatDate(d);
  }
  if (text === 'next month') {
    const d = new Date(now); d.setMonth(d.getMonth() + 1); return formatDate(d);
  }
  if (text === 'this weekend' || text === 'weekend') {
    const d = new Date(now);
    const daysUntilSaturday = (6 - d.getDay() + 7) % 7;
    d.setDate(d.getDate() + daysUntilSaturday);
    return formatDate(d);
  }
  if (text === 'next weekend') {
    const d = new Date(now);
    const daysUntilNextSaturday = ((6 - d.getDay() + 7) % 7) + 7;
    d.setDate(d.getDate() + daysUntilNextSaturday);
    return formatDate(d);
  }

  const days = ['sunday','monday','tuesday','wednesday','thursday','friday','saturday'];
  const shortDays = ['sun','mon','tue','wed','thu','fri','sat'];
  const nextMatch = text.match(/^(?:next\s+)?(\w+)$/);
  if (nextMatch) {
    let dayIdx = days.indexOf(nextMatch[1]);
    if (dayIdx === -1) dayIdx = shortDays.indexOf(nextMatch[1]);
    if (dayIdx !== -1) {
      const d = new Date(now);
      const diff = (dayIdx - d.getDay() + 7) % 7 || 7;
      d.setDate(d.getDate() + diff);
      return formatDate(d);
    }
  }

  const inMatch = text.match(/^in\s+(\d+)\s+(day|days|week|weeks)$/);
  if (inMatch) {
    const d = new Date(now);
    const n = parseInt(inMatch[1]);
    if (inMatch[2].startsWith('week')) d.setDate(d.getDate() + n * 7);
    else d.setDate(d.getDate() + n);
    return formatDate(d);
  }
  const inWordMatch = text.match(/^in\s+(a|an|one|two|three|four|five|six|seven|eight|nine|ten)\s+(day|days|week|weeks)$/);
  if (inWordMatch) {
    const wordToNum = { a:1, an:1, one:1, two:2, three:3, four:4, five:5, six:6, seven:7, eight:8, nine:9, ten:10 };
    const d = new Date(now);
    const n = wordToNum[inWordMatch[1]];
    if (inWordMatch[2].startsWith('week')) d.setDate(d.getDate() + n * 7);
    else d.setDate(d.getDate() + n);
    return formatDate(d);
  }

  const months = {
    jan:0,january:0,feb:1,february:1,mar:2,march:2,apr:3,april:3,
    may:4,jun:5,june:5,jul:6,july:6,aug:7,august:7,sep:8,sept:8,
    september:8,oct:9,october:9,nov:10,november:10,dec:11,december:11
  };

  const mdMatch = text.match(/^(\w+)\s+(\d{1,2})(?:st|nd|rd|th)?(?:\s*,?\s*(\d{2,4}))?$/);
  if (mdMatch) {
    const mIdx = months[mdMatch[1]];
    if (mIdx !== undefined) {
      let y = mdMatch[3] ? (mdMatch[3].length === 2 ? 2000 + parseInt(mdMatch[3]) : parseInt(mdMatch[3])) : year;
      const d = new Date(y, mIdx, parseInt(mdMatch[2]));
      if (d < now && !mdMatch[3]) d.setFullYear(y + 1);
      return formatDate(d);
    }
  }

  const dmMatch = text.match(/^(\d{1,2})(?:st|nd|rd|th)?\s+(\w+)(?:\s*,?\s*(\d{2,4}))?$/);
  if (dmMatch) {
    const mIdx = months[dmMatch[2]];
    if (mIdx !== undefined) {
      let y = dmMatch[3] ? (dmMatch[3].length === 2 ? 2000 + parseInt(dmMatch[3]) : parseInt(dmMatch[3])) : year;
      const d = new Date(y, mIdx, parseInt(dmMatch[1]));
      if (d < now && !dmMatch[3]) d.setFullYear(y + 1);
      return formatDate(d);
    }
  }

  const slashMatch = text.match(/^(\d{1,2})\/(\d{1,2})(?:\/(\d{2,4}))?$/);
  if (slashMatch) {
    let y = slashMatch[3] ? (slashMatch[3].length === 2 ? 2000 + parseInt(slashMatch[3]) : parseInt(slashMatch[3])) : year;
    const d = new Date(y, parseInt(slashMatch[1]) - 1, parseInt(slashMatch[2]));
    if (d < now && !slashMatch[3]) d.setFullYear(y + 1);
    return formatDate(d);
  }

  return input.trim();
}

function formatDate(d) {
  const monthNames = ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'];
  return monthNames[d.getMonth()] + ' ' + d.getDate();
}

function parseDateBack(str) {
  if (!str || !str.trim()) return null;
  const monthNames = ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'];
  const m = str.match(/^(\w+)\s+(\d+)$/);
  if (!m) return null;
  const mIdx = monthNames.indexOf(m[1]);
  if (mIdx === -1) return null;
  const now = new Date();
  let d = new Date(now.getFullYear(), mIdx, parseInt(m[2]));
  // If the date is far in the past (> 6 months ago), assume next year
  const sixMonthsAgo = new Date(now);
  sixMonthsAgo.setMonth(sixMonthsAgo.getMonth() - 6);
  if (d < sixMonthsAgo) d.setFullYear(d.getFullYear() + 1);
  return d;
}

function isOverdue(dateStr) {
  const d = parseDateBack(dateStr);
  if (!d) return false;
  const now = new Date();
  now.setHours(0, 0, 0, 0);
  return d < now;
}

// --- Priority cycling ---

function cyclePriority(dot) {
  if (dot.classList.contains('red')) {
    dot.classList.remove('red');
    dot.dataset.priority = '';
  } else if (dot.classList.contains('orange')) {
    dot.classList.remove('orange');
    dot.classList.add('red');
    dot.dataset.priority = 'red';
  } else {
    dot.classList.add('orange');
    dot.dataset.priority = 'orange';
  }
  saveTasks();
}

// --- Note field ---

function createNoteField(row, noteText = '') {
  let note = row.querySelector('.note-field');
  if (note) {
    note.focus();
    return note;
  }
  note = document.createElement('textarea');
  note.className = 'note-field';
  note.placeholder = 'Note...';
  note.value = noteText;
  note.rows = 1;
  row.classList.add('has-note');
  row.appendChild(note);

  const autoResize = () => {
    note.style.height = 'auto';
    note.style.height = note.scrollHeight + 'px';
  };
  note.addEventListener('input', () => { autoResize(); saveTasks(); });
  setTimeout(autoResize, 0);

  note.addEventListener('blur', () => {
    if (!note.value.trim()) {
      row.classList.remove('has-note');
      note.remove();
      saveTasks();
    }
  });

  note.addEventListener('keydown', (e) => {
    if (e.key === 'Escape') {
      note.blur();
    }
  });

  return note;
}

// --- Section Headers ---

function createSectionRow(label = '') {
  const row = document.createElement('div');
  row.className = 'section-row';
  row.dataset.type = 'section';

  const input = document.createElement('input');
  input.type = 'text';
  input.className = 'section-label';
  input.placeholder = 'Section name...';
  input.value = label;

  const delBtn = document.createElement('button');
  delBtn.className = 'section-delete-btn';
  delBtn.innerHTML = '&times;';

  input.addEventListener('input', saveTasks);
  input.addEventListener('blur', () => {
    if (!input.value.trim()) {
      row.style.transition = 'opacity 0.25s ease';
      row.style.opacity = '0';
      setTimeout(() => { row.remove(); saveTasks(); }, 250);
    }
  });

  delBtn.addEventListener('click', () => {
    row.style.transition = 'opacity 0.25s ease';
    row.style.opacity = '0';
    setTimeout(() => { row.remove(); saveTasks(); }, 250);
  });

  row.appendChild(input);
  row.appendChild(delBtn);
  return row;
}

// --- Task Row ---

function createTaskRow(title = '', date = '', priority = '', note = '', completed = false, status = '') {
  const row = document.createElement('div');
  row.className = 'task-row';
  row.dataset.type = 'task';
  row.draggable = !disableDragReorder;

  // Priority dot
  const dot = document.createElement('div');
  dot.className = 'priority-dot' + (priority ? ' ' + priority : '');
  dot.dataset.priority = priority || '';
  dot.addEventListener('click', (e) => {
    e.stopPropagation();
    cyclePriority(dot);
  });

  const titleInput = document.createElement('input');
  titleInput.type = 'text';
  titleInput.className = 'task-title-input';
  titleInput.placeholder = 'What needs doing?';
  titleInput.value = title;

  const titleCell = document.createElement('div');
  titleCell.className = 'task-title-cell';

  const completeBtn = document.createElement('button');
  completeBtn.type = 'button';
  completeBtn.className = 'task-complete-btn';
  completeBtn.innerHTML = '&#10003;';
  completeBtn.setAttribute('draggable', 'false');

  // Status field
  const statusWrapper = createStatusField(row, status);

  const dateInput = document.createElement('input');
  dateInput.type = 'text';
  dateInput.className = 'task-date-input';
  dateInput.placeholder = 'When';
  dateInput.value = date;

  const deleteBtn = document.createElement('button');
  deleteBtn.className = 'delete-btn';
  deleteBtn.innerHTML = '&times;';
  deleteBtn.setAttribute('aria-label', 'Delete task');

  // Overdue check
  const checkOverdue = () => {
    if (isOverdue(dateInput.value) && !row.classList.contains('completed')) {
      dateInput.classList.add('overdue');
    } else {
      dateInput.classList.remove('overdue');
    }
  };
  checkOverdue();

  completeBtn.addEventListener('mousedown', (e) => {
    // Prevent drag start when user clicks complete
    e.stopPropagation();
  });

  // Completion is explicit via a dedicated button, editing remains single-click/focus
  completeBtn.addEventListener('click', (e) => {
    e.preventDefault();
    e.stopPropagation();
    if (!titleInput.value.trim()) return;
    toggleComplete(row);
  });

  // Parse date on blur
  dateInput.addEventListener('blur', () => {
    dateInput.value = parseNaturalDate(dateInput.value);
    checkOverdue();
  });

  // Enter on date creates new row, Shift+Enter opens note
  dateInput.addEventListener('keydown', (e) => {
    if (e.key === 'Enter' && e.shiftKey) {
      e.preventDefault();
      const noteField = createNoteField(row);
      noteField.focus();
    } else if (e.key === 'Enter') {
      e.preventDefault();
      dateInput.value = parseNaturalDate(dateInput.value);
      checkOverdue();
      const newRow = createTaskRow();
      if (row.nextSibling) {
        taskList.insertBefore(newRow, row.nextSibling);
      } else {
        taskList.appendChild(newRow);
      }
      newRow.querySelector('.task-title-input').focus();
    }
  });

  // Shift+Enter on title opens note, Enter goes to status
  titleInput.addEventListener('keydown', (e) => {
    if (e.key === 'Enter' && e.shiftKey) {
      e.preventDefault();
      const noteField = createNoteField(row);
      noteField.focus();
    } else if (e.key === 'Enter') {
      e.preventDefault();
      const statusInput = row.querySelector('.task-status-input');
      if (statusInput) statusInput.focus();
      else dateInput.focus();
    }
  });

  // Delete row
  deleteBtn.addEventListener('click', () => {
    row.style.transition = 'opacity 0.25s ease, transform 0.25s ease';
    row.style.opacity = '0';
    row.style.transform = 'translateX(-20px)';
    setTimeout(() => { row.remove(); saveTasks(); }, 250);
  });

  // Drag events
  row.addEventListener('dragstart', (e) => {
    row.classList.add('dragging');
    e.dataTransfer.effectAllowed = 'move';
    e.dataTransfer.setData('text/plain', '');
    // Delay so the dragging class applies visually
    requestAnimationFrame(() => row.classList.add('dragging'));
  });

  row.addEventListener('dragend', () => {
    row.classList.remove('dragging');
    clearDropIndicators();
    saveTasks();
  });

  row.addEventListener('dragover', (e) => {
    e.preventDefault();
    e.dataTransfer.dropEffect = 'move';
    const dragging = taskList.querySelector('.dragging');
    if (!dragging || dragging === row) return;
    clearDropIndicators();
    const rect = row.getBoundingClientRect();
    const mid = rect.top + rect.height / 2;
    if (e.clientY < mid) {
      row.classList.add('drag-over-top');
    } else {
      row.classList.add('drag-over-bottom');
    }
  });

  row.addEventListener('dragleave', () => {
    row.classList.remove('drag-over-top', 'drag-over-bottom');
  });

  row.addEventListener('drop', (e) => {
    e.preventDefault();
    const dragging = taskList.querySelector('.dragging');
    if (!dragging || dragging === row) return;
    const rect = row.getBoundingClientRect();
    const mid = rect.top + rect.height / 2;
    if (e.clientY < mid) {
      taskList.insertBefore(dragging, row);
    } else {
      taskList.insertBefore(dragging, row.nextSibling);
    }
    clearDropIndicators();
    saveTasks();
  });

  titleCell.appendChild(completeBtn);
  titleCell.appendChild(titleInput);

  row.appendChild(dot);
  row.appendChild(titleCell);
  row.appendChild(statusWrapper);
  row.appendChild(dateInput);
  row.appendChild(deleteBtn);

  // Set completed state
  if (completed) {
    row.classList.add('completed');
    checkOverdue();
  }
  syncCompleteButtonState(row);

  // Restore note if present
  if (note) {
    createNoteField(row, note);
  }

  return row;
}

function clearDropIndicators() {
  taskList.querySelectorAll('.drag-over-top, .drag-over-bottom').forEach(el => {
    el.classList.remove('drag-over-top', 'drag-over-bottom');
  });
}

// --- Toggle completion ---

function toggleComplete(row) {
  const wasCompleted = row.classList.contains('completed');
  row.classList.toggle('completed');

  const dateInput = row.querySelector('.task-date-input');
  if (row.classList.contains('completed')) {
    dateInput.classList.remove('overdue');
  } else if (isOverdue(dateInput.value)) {
    dateInput.classList.add('overdue');
  }
  syncCompleteButtonState(row);

  saveTasks();

  // Drift completed tasks to bottom after a moment
  if (!wasCompleted) {
    setTimeout(() => {
      driftCompletedToBottom();
    }, 600);
  }
}

function syncCompleteButtonState(row) {
  const btn = row.querySelector('.task-complete-btn');
  if (!btn) return;
  const completed = row.classList.contains('completed');
  btn.setAttribute('aria-pressed', completed ? 'true' : 'false');
  btn.setAttribute('aria-label', completed ? 'Mark task incomplete' : 'Mark task complete');
  btn.title = completed ? 'Mark incomplete' : 'Mark complete';
}

function driftCompletedToBottom() {
  const rows = Array.from(taskList.children);
  const completedTasks = rows.filter(r => r.dataset.type === 'task' && r.classList.contains('completed'));
  const other = rows.filter(r => !(r.dataset.type === 'task' && r.classList.contains('completed')));

  // Only reorder if there are completed tasks mixed in with uncompleted
  let needsReorder = false;
  let seenCompleted = false;
  for (const r of rows) {
    if (r.dataset.type === 'task' && r.classList.contains('completed')) {
      seenCompleted = true;
    } else if (r.dataset.type === 'task' && seenCompleted) {
      needsReorder = true;
      break;
    }
  }

  if (needsReorder) {
    other.forEach(r => taskList.appendChild(r));
    completedTasks.forEach(r => taskList.appendChild(r));
    saveTasks();
  }
}

// --- Persistent Storage ---
// Uses window.storage (injected API) if available, falls back to localStorage

function serializeTasks() {
  const children = taskList.children;
  const items = [];
  for (const child of children) {
    if (child.dataset.type === 'section') {
      items.push({
        type: 'section',
        label: child.querySelector('.section-label').value
      });
    } else if (child.dataset.type === 'task') {
      const title = child.querySelector('.task-title-input').value;
      const date = child.querySelector('.task-date-input').value;
      const priority = child.querySelector('.priority-dot').dataset.priority || '';
      const statusEl = child.querySelector('.task-status-input');
      const status = statusEl ? statusEl.value : '';
      const noteEl = child.querySelector('.note-field');
      const note = noteEl ? noteEl.value : '';
      const completed = child.classList.contains('completed');
      if (title || date || note) {
        items.push({ type: 'task', title, date, priority, note, completed, status });
      }
    }
  }
  return JSON.stringify(items);
}

function parseSerializedTasks() {
  try {
    return JSON.parse(serializeTasks());
  } catch (e) {
    return [];
  }
}

function sanitizeStatusList(statuses) {
  if (!Array.isArray(statuses)) return [];
  const seen = new Set();
  const cleaned = [];
  statuses.forEach((value) => {
    if (typeof value !== 'string') return;
    const trimmed = value.trim();
    if (!trimmed || seen.has(trimmed)) return;
    seen.add(trimmed);
    cleaned.push(trimmed);
  });
  return cleaned;
}

function populateTaskList(items) {
  taskList.innerHTML = '';
  if (!Array.isArray(items)) return;
  items.forEach(item => {
    if (item.type === 'section') {
      const row = createSectionRow(item.label || '');
      taskList.appendChild(row);
    } else {
      // Support legacy format (no type field)
      if (item.status) statusSuggestions.add(item.status);
      const row = createTaskRow(
        item.title || '',
        item.date || '',
        item.priority || '',
        item.note || '',
        item.completed || false,
        item.status || ''
      );
      taskList.appendChild(row);
    }
  });
}

async function saveTasks() {
  const json = serializeTasks();
  // Try window.storage first (injected API from host environment)
  if (window.storage && typeof window.storage.set === 'function') {
    try {
      await window.storage.set('tasks', json);
      return;
    } catch (e) { /* fall through to localStorage */ }
  }
  // Fallback to localStorage
  try {
    localStorage.setItem('tasktrak_tasks', json);
  } catch (e) {
    console.log('No storage available');
  }
}

async function loadTasks() {
  let items = null;

  // Try window.storage first
  if (window.storage && typeof window.storage.get === 'function') {
    try {
      const result = await window.storage.get('tasks');
      items = JSON.parse(result.value);
    } catch (e) { /* fall through */ }
  }

  // Fallback to localStorage
  if (!items) {
    try {
      const raw = localStorage.getItem('tasktrak_tasks');
      if (raw) items = JSON.parse(raw);
    } catch (e) { /* no storage */ }
  }

  if (items && items.length > 0) {
    populateTaskList(items);
    return true;
  }
  return false;
}

function getExportPayload() {
  collectStatuses();
  return {
    app: 'tasktrak',
    version: 1,
    exportedAt: new Date().toISOString(),
    tasks: parseSerializedTasks(),
    statuses: Array.from(statusSuggestions)
  };
}

function exportData() {
  const payload = getExportPayload();
  const blob = new Blob([JSON.stringify(payload, null, 2)], { type: 'application/json' });
  const url = URL.createObjectURL(blob);
  const link = document.createElement('a');
  link.href = url;
  link.download = `tasktrak-export-${new Date().toISOString().slice(0, 10)}.json`;
  document.body.appendChild(link);
  link.click();
  link.remove();
  setTimeout(() => URL.revokeObjectURL(url), 0);
}

function parseImportPayload(rawText) {
  let data;
  try {
    data = JSON.parse(rawText);
  } catch (e) {
    throw new Error('Invalid JSON file.');
  }

  if (Array.isArray(data)) {
    return { tasks: data, statuses: null };
  }

  if (!data || typeof data !== 'object') {
    throw new Error('Import format not recognized.');
  }

  const tasks = Array.isArray(data.tasks)
    ? data.tasks
    : (Array.isArray(data.items) ? data.items : null);
  if (!tasks) {
    throw new Error('Import file must include a tasks array.');
  }

  const statuses = Array.isArray(data.statuses) ? data.statuses : null;
  return { tasks, statuses };
}

function applyImportedData(tasks, statuses) {
  const importedStatuses = sanitizeStatusList(statuses);
  statusSuggestions.clear();
  (importedStatuses.length ? importedStatuses : DEFAULT_STATUSES).forEach(s => statusSuggestions.add(s));

  populateTaskList(tasks);
  if (taskList.children.length === 0) {
    taskList.appendChild(createTaskRow());
  }
  collectStatuses();
  saveTasks();
  saveStatusSuggestions();
}

// Auto-save on any input change
function attachSaveListeners(row) {
  const inputs = row.querySelectorAll('input, textarea');
  inputs.forEach(input => {
    input.addEventListener('input', saveTasks);
    input.addEventListener('blur', () => setTimeout(saveTasks, 50));
  });
}

// Patch createTaskRow to attach save listeners
const _origCreateTask = createTaskRow;
createTaskRow = function(title, date, priority, note, completed, status) {
  const row = _origCreateTask(title, date, priority, note, completed, status);
  attachSaveListeners(row);
  return row;
};

const _origCreateSection = createSectionRow;
createSectionRow = function(label) {
  const row = _origCreateSection(label);
  attachSaveListeners(row);
  return row;
};

// Click add row to create new task
addRow.addEventListener('click', () => {
  const row = createTaskRow();
  taskList.appendChild(row);
  const titleInput = row.querySelector('.task-title-input');
  titleInput.focus();
  // Ensure focus remains on title even if row animations are still settling
  setTimeout(() => titleInput.focus(), 10);
});

// Click add section
addSectionBtn.addEventListener('click', () => {
  const row = createSectionRow();
  taskList.appendChild(row);
  row.querySelector('.section-label').focus();
});

exportDataBtn.addEventListener('click', exportData);

importDataBtn.addEventListener('click', () => {
  importFileInput.click();
});

importFileInput.addEventListener('change', async () => {
  const file = importFileInput.files && importFileInput.files[0];
  if (!file) return;

  try {
    const existingTasks = parseSerializedTasks();
    if (existingTasks.length > 0) {
      const ok = window.confirm('Import will replace your current tasks and statuses. Continue?');
      if (!ok) return;
    }

    const text = await file.text();
    const { tasks, statuses } = parseImportPayload(text);
    applyImportedData(tasks, statuses);

    const titleInput = taskList.querySelector('.task-title-input');
    if (titleInput) titleInput.focus();
    alert('Import completed.');
  } catch (e) {
    alert(`Import failed: ${e.message}`);
  } finally {
    importFileInput.value = '';
  }
});

// Also allow drag on sections
taskList.addEventListener('dragover', (e) => {
  e.preventDefault();
});

// --- Column Sorting ---

let currentSort = { field: null, asc: true };

function sortTasks(field) {
  // Toggle direction if same field, otherwise default asc
  if (currentSort.field === field) {
    currentSort.asc = !currentSort.asc;
  } else {
    currentSort.field = field;
    currentSort.asc = true;
  }

  // Update glyph visuals
  document.querySelectorAll('.header-row .sort-glyph').forEach(g => {
    g.classList.remove('active', 'desc');
  });
  const activeHeader = document.querySelector(`.header-row [data-sort="${field}"]`);
  if (activeHeader) {
    const glyph = activeHeader.querySelector('.sort-glyph');
    glyph.classList.add('active');
    if (!currentSort.asc) glyph.classList.add('desc');
  }

  // Collect task rows grouped by sections
  const children = Array.from(taskList.children);
  const groups = []; // each group: { section: element|null, tasks: [] }
  let currentGroup = { section: null, tasks: [] };

  children.forEach(child => {
    if (child.dataset.type === 'section') {
      if (currentGroup.section || currentGroup.tasks.length) {
        groups.push(currentGroup);
      }
      currentGroup = { section: child, tasks: [] };
    } else if (child.dataset.type === 'task') {
      currentGroup.tasks.push(child);
    }
  });
  groups.push(currentGroup);

  // Sort each group's tasks
  groups.forEach(group => {
    group.tasks.sort((a, b) => {
      let va, vb;
      if (field === 'title') {
        va = (a.querySelector('.task-title-input').value || '').toLowerCase();
        vb = (b.querySelector('.task-title-input').value || '').toLowerCase();
      } else if (field === 'status') {
        va = (a.querySelector('.task-status-input')?.value || '').toLowerCase();
        vb = (b.querySelector('.task-status-input')?.value || '').toLowerCase();
      } else if (field === 'date') {
        const da = parseDateBack(a.querySelector('.task-date-input').value);
        const db = parseDateBack(b.querySelector('.task-date-input').value);
        va = da ? da.getTime() : (currentSort.asc ? Infinity : -Infinity);
        vb = db ? db.getTime() : (currentSort.asc ? Infinity : -Infinity);
      }
      if (va < vb) return currentSort.asc ? -1 : 1;
      if (va > vb) return currentSort.asc ? 1 : -1;
      return 0;
    });
  });

  // Re-append in order
  taskList.innerHTML = '';
  groups.forEach(group => {
    if (group.section) taskList.appendChild(group.section);
    group.tasks.forEach(t => taskList.appendChild(t));
  });

  saveTasks();
}

// Attach click handlers to header columns
document.querySelectorAll('.header-row [data-sort]').forEach(header => {
  header.addEventListener('click', () => {
    sortTasks(header.dataset.sort);
  });
});

// --- Status Manager ---

const statusManagerOverlay = document.getElementById('status-manager-overlay');
const statusManagerList = document.getElementById('status-manager-list');
const statusManagerNewInput = document.getElementById('status-manager-new');
const statusManagerAddBtn = document.getElementById('status-manager-add-btn');
const statusManagerCloseBtn = document.getElementById('status-manager-close');
const manageStatusesBtn = document.getElementById('manage-statuses-btn');

function getStatusColor(name) {
  const key = name.toLowerCase();
  if (statusColorMap[key]) {
    const map = { 'status-pending': '#ff9f0a', 'status-waiting': '#bf5af2', 'status-due': '#ff453a', 'status-done': '#30d158', 'status-blocked': '#ff6961' };
    return map[statusColorMap[key]] || '#64d2ff';
  }
  return '#64d2ff';
}

function renderStatusManager() {
  statusManagerList.innerHTML = '';
  const statuses = Array.from(statusSuggestions);
  statuses.forEach((s) => {
    const item = document.createElement('div');
    item.className = 'status-manager-item';

    const dot = document.createElement('div');
    dot.className = 'color-dot';
    dot.style.background = getStatusColor(s);

    const input = document.createElement('input');
    input.type = 'text';
    input.value = s;
    const originalVal = s;

    input.addEventListener('blur', () => {
      const newVal = input.value.trim();
      if (!newVal) {
        // Treat empty as delete
        statusSuggestions.delete(originalVal);
        renderStatusManager();
        saveStatusSuggestions();
        return;
      }
      if (newVal !== originalVal) {
        statusSuggestions.delete(originalVal);
        statusSuggestions.add(newVal);
        // Rename in existing tasks
        taskList.querySelectorAll('.task-status-input').forEach(si => {
          if (si.value === originalVal) {
            si.value = newVal;
            applyStatusColor(si);
          }
        });
        renderStatusManager();
        saveTasks();
        saveStatusSuggestions();
      }
    });

    input.addEventListener('keydown', (e) => {
      if (e.key === 'Enter') { e.preventDefault(); input.blur(); }
    });

    const delBtn = document.createElement('button');
    delBtn.className = 'status-del-btn';
    delBtn.innerHTML = '&times;';
    delBtn.addEventListener('click', () => {
      statusSuggestions.delete(s);
      renderStatusManager();
      saveStatusSuggestions();
    });

    item.appendChild(dot);
    item.appendChild(input);
    item.appendChild(delBtn);
    statusManagerList.appendChild(item);
  });
}

function addNewStatus() {
  const val = statusManagerNewInput.value.trim();
  if (!val) return;
  statusSuggestions.add(val);
  statusManagerNewInput.value = '';
  renderStatusManager();
  saveStatusSuggestions();
}

manageStatusesBtn.addEventListener('click', () => {
  collectStatuses();
  renderStatusManager();
  statusManagerOverlay.classList.add('visible');
});

statusManagerCloseBtn.addEventListener('click', () => {
  statusManagerOverlay.classList.remove('visible');
});

statusManagerOverlay.addEventListener('click', (e) => {
  if (e.target === statusManagerOverlay) {
    statusManagerOverlay.classList.remove('visible');
  }
});

statusManagerAddBtn.addEventListener('click', addNewStatus);
statusManagerNewInput.addEventListener('keydown', (e) => {
  if (e.key === 'Enter') { e.preventDefault(); addNewStatus(); }
});

// Persist status suggestions separately
async function saveStatusSuggestions() {
  const arr = Array.from(statusSuggestions);
  const json = JSON.stringify(arr);
  if (window.storage && typeof window.storage.set === 'function') {
    try { await window.storage.set('statuses', json); return; } catch (e) {}
  }
  try { localStorage.setItem('tasktrak_statuses', json); } catch (e) {}
}

async function loadStatusSuggestions() {
  let arr = null;
  if (window.storage && typeof window.storage.get === 'function') {
    try {
      const result = await window.storage.get('statuses');
      arr = JSON.parse(result.value);
    } catch (e) {}
  }
  if (!arr) {
    try {
      const raw = localStorage.getItem('tasktrak_statuses');
      if (raw) arr = JSON.parse(raw);
    } catch (e) {}
  }
  if (Array.isArray(arr)) {
    const cleaned = sanitizeStatusList(arr);
    statusSuggestions.clear();
    (cleaned.length ? cleaned : DEFAULT_STATUSES).forEach(s => statusSuggestions.add(s));
  }
}

// Load saved tasks, or start with one empty row
loadStatusSuggestions().then(() => loadTasks()).then(loaded => {
  if (!loaded) {
    const first = createTaskRow();
    taskList.appendChild(first);
    setTimeout(() => {
      const titleInput = first.querySelector('.task-title-input');
      titleInput.focus();
      // Need to let the title input be editable right away for first task
    }, 100);
  }
  // Check all overdue dates on load
  taskList.querySelectorAll('.task-date-input').forEach(input => {
    if (isOverdue(input.value)) {
      const row = input.closest('.task-row');
      if (row && !row.classList.contains('completed')) {
        input.classList.add('overdue');
      }
    }
  });
});
</script>
</body>
</html>
